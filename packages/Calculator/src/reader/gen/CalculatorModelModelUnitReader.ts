// Generated by the Freon Language Generator.
import {FreReader, FreModelUnit, FreNode} from "@freon4dsl/core";
import { CalculatorModel } from "../../language/gen";
import { CalculatorModelGrammarStr } from "./CalculatorModelGrammar";
import { CalculatorModelSemanticAnalyser } from "./CalculatorModelSemanticAnalyser";
import {
    Agl,
    InputLocation,
    KtList,
    KtMap,
    LanguageProcessor, LanguageProcessorResult,
    Nullable, ProcessResult,
    SemanticAnalyser,
    SemanticAnalysisOptions,
    SemanticAnalysisResult, SemanticAnalysisResultDefault,
    Sentence,
    SentenceContext,
    SpptDataNodeInfo,
    SyntaxAnalyserByMethodRegistrationAbstract
} from 'net.akehurst.language-agl-processor/net.akehurst.language-agl-processor.mjs';

import {
    IssueHolder
} from 'net.akehurst.language-agl-processor/net.akehurst.language-agl-parser.mjs';
import {CalculatorModelSyntaxAnalyser} from "./CalculatorModelSyntaxAnalyser";

// @ts-ignore
class MyContext implements SentenceContext<FreNode> {
    constructor(readonly predefined: Map<string, FreNode>) {
    }
}
/**
 *   Class CalculatorModelModelUnitReader is a wrapper for the various parsers of
 *   modelunits.
 */
export class CalculatorModelModelUnitReader implements FreReader {
    analyser: CalculatorModelSyntaxAnalyser = new CalculatorModelSyntaxAnalyser();
    res: LanguageProcessorResult<any, any> = Agl.getInstance().processorFromString(
        CalculatorModelGrammarStr,
        Agl.getInstance().configuration(undefined, (b) => {
            b.syntaxAnalyserResolverResult(() => this.analyser);
        })
    );
    parser: LanguageProcessor<CalculatorModel, MyContext> = this.res.processor;

    /**
     * Parses and performs a syntax analysis on 'sentence', using the parser and analyser
     * for 'metatype', if available. If 'sentence' is correct, a model unit will be created,
     * otherwise an error wil be thrown containing the parse or analysis error.
     * @param sentence      the input string which will be parsed
     * @param metatype      the type of the unit to be created
     * @param model         the model to which the unit will be added
     * @param sourceName    the (optional) name of the source that contains 'sentence'
     */
    readFromString(sentence: string, metatype: string, model: CalculatorModel, sourceName?: string): FreModelUnit {
        this.analyser.sourceName = sourceName;
        let startRule: string = "";
        // choose the correct parser
        if (metatype === "Calculator") {
            startRule = "Calculator";
        }

        // parse the input
        let unit: FreModelUnit = null;
        if (this.parser) {
            try {
                let parseResult: ProcessResult<CalculatorModel>;
                const options = this.parser.optionsDefault();
                if (startRule.length > 0) {
                    options.parse.goalRuleName = startRule;
                    parseResult = this.parser.process(sentence, options);
                } else {
                    parseResult = this.parser.process(sentence, null);
                }
                console.log("ZZZ "+ parseResult.asm.constructor.name)
                unit = parseResult.asm ;
            } catch (e) {
                // strip the error message, otherwise it's too long for the webapp
                let mess = e.message.replace("Could not match goal,", "Parse error in " + sourceName + ":");
                if (!!mess && mess.length > 0) {
                    console.log(mess);
                    throw new Error(mess);
                } else {
                    throw e;
                }
            }
            // this.parser.issues.errors.toArray().forEach( iss => {
            //     console.log(iss.toString());
            // });
            // console.log(this.parser.issues.errors.constructor.name)
            // do semantic analysis taking into account the whole model, because references could be pointing anywhere
            if (!!model) {
                try {
                    if (model.getUnits().filter((existing) => existing.name === unit.name).length > 0) {
                        throw new Error(`Unit named '${unit.name}' already exists.`);
                    } else {
                        model.addUnit(unit);
                        const semAnalyser = new CalculatorModelSemanticAnalyser();
                        semAnalyser.correct(unit);
                    }
                } catch (e) {
                    console.log(e.message);
                    throw e;
                }
            }
        } else {
            throw new Error(`No parser for ${metatype} available: grammar incorrect.`);
        }
        return unit;
    }
}


